From: Chester Lin <clin@suse.com>
Date: Mon, 11 Nov 2019 14:30:07 +0100
Subject: [PATCH] ARM: efistub: efistub debug feature
Patch-mainline: Not yet, debugging
References: bsc#1145646

arm efistub debug

Signed-of-by: Chester Lin <clin@suse.com>
---
 drivers/firmware/efi/libstub/arm-stub.c        |   15 +++++++++++++++
 drivers/firmware/efi/libstub/efi-stub-helper.c |   21 ++++++++++++++++++++-
 2 files changed, 35 insertions(+), 1 deletion(-)

--- a/drivers/firmware/efi/libstub/arm-stub.c
+++ b/drivers/firmware/efi/libstub/arm-stub.c
@@ -131,14 +131,20 @@ unsigned long efi_entry(void *handle, ef
 	enum efi_secureboot_mode secure_boot;
 	struct screen_info *si;
 
+	pr_efi(sys_table, "dbg: efi_entry get started\n");
+
 	/* Check if we were booted by the EFI firmware */
 	if (sys_table->hdr.signature != EFI_SYSTEM_TABLE_SIGNATURE)
 		goto fail;
 
+	pr_efi(sys_table, "dbg: sys_table signature checked\n");
+
 	status = check_platform_features(sys_table);
 	if (status != EFI_SUCCESS)
 		goto fail;
 
+	pr_efi(sys_table, "dbg: platform features checked\n");
+
 	/*
 	 * Get a handle to the loaded image protocol.  This is used to get
 	 * information about the running image, such as size and the command
@@ -146,6 +152,9 @@ unsigned long efi_entry(void *handle, ef
 	 */
 	status = sys_table->boottime->handle_protocol(handle,
 					&loaded_image_proto, (void *)&image);
+
+	pr_efi(sys_table, "dbg: boottime: handle_protocol has been called\n");
+
 	if (status != EFI_SUCCESS) {
 		pr_efi_err(sys_table, "Failed to get loaded image protocol\n");
 		goto fail;
@@ -157,6 +166,8 @@ unsigned long efi_entry(void *handle, ef
 		goto fail;
 	}
 
+	pr_efi(sys_table, "dbg: get_dram_base has been called\n");
+
 	/*
 	 * Get the command line from EFI, using the LOADED_IMAGE
 	 * protocol. We are going to copy the command line into the
@@ -168,11 +179,15 @@ unsigned long efi_entry(void *handle, ef
 		goto fail;
 	}
 
+	pr_efi(sys_table, "dbg: get cmdline\n");
+
 	if (IS_ENABLED(CONFIG_CMDLINE_EXTEND) ||
 	    IS_ENABLED(CONFIG_CMDLINE_FORCE) ||
 	    cmdline_size == 0)
 		efi_parse_options(CONFIG_CMDLINE);
 
+	pr_efi(sys_table, "dbg: check-point\n");
+
 	if (!IS_ENABLED(CONFIG_CMDLINE_FORCE) && cmdline_size > 0)
 		efi_parse_options(cmdline_ptr);
 
--- a/drivers/firmware/efi/libstub/efi-stub-helper.c
+++ b/drivers/firmware/efi/libstub/efi-stub-helper.c
@@ -819,8 +819,11 @@ char *efi_convert_cmdline(efi_system_tab
 	efi_status_t status;
 	u16 zero = 0;
 
+	pr_efi(sys_table, "dbg: convert-start\n");
+
 	if (options) {
 		s2 = options;
+		pr_efi(sys_table, "search options\n");
 		while (*s2 && *s2 != '\n'
 		       && options_chars < load_options_chars) {
 			options_bytes += efi_utf8_bytes(*s2++);
@@ -828,6 +831,8 @@ char *efi_convert_cmdline(efi_system_tab
 		}
 	}
 
+	pr_efi(sys_table, "dbg: check chars\n");
+
 	if (!options_chars) {
 		/* No command line options, so return empty string*/
 		options = &zero;
@@ -835,18 +840,32 @@ char *efi_convert_cmdline(efi_system_tab
 
 	options_bytes++;	/* NUL termination */
 
+	pr_efi(sys_table, "dbg: call efi_high_alloc\n");
+
 	status = efi_high_alloc(sys_table_arg, options_bytes, 0,
 				&cmdline_addr, MAX_CMDLINE_ADDRESS);
+
+	pr_efi(sys_table, "done alloc\n");
+
 	if (status != EFI_SUCCESS)
 		return NULL;
 
+	pr_efi(sys_table, "s1\n");
+
 	s1 = (u8 *)cmdline_addr;
+
+	pr_efi(sys_table, "s2\n");
+
 	s2 = (const u16 *)options;
 
+	pr_efi(sys_table, "convert\n");
+
 	s1 = efi_utf16_to_utf8(s1, s2, options_chars);
+	pr_efi(sys_table, "term char\n");
 	*s1 = '\0';
-
+	pr_efi(sys_table, "fill len\n");
 	*cmd_line_len = options_bytes;
+	pr_efi(sys_table, "convert-end\n");
 	return (char *)cmdline_addr;
 }
 
