From 20e98a22421d215b600c5f86f07e0470aa56369f Mon Sep 17 00:00:00 2001
From: Chester Lin <clin@suse.com>
Date: Fri, 18 Oct 2019 17:12:26 +0800
Subject: [PATCH] brcmstb: Add debug logs to investigate PCI failure
Patch-Mainline: Not yet, a temp workaround
References: rpi4 porting

Chester's debug patch.

Signed-off-by: Chester Lin <clin@suse.com>
---
 drivers/pci/controller/pcie-brcmstb.c |   39 +++++++++++++++++++++++++++-------
 drivers/soc/bcm/brcmstb/memory.c      |    5 ++--
 2 files changed, 35 insertions(+), 9 deletions(-)

--- a/drivers/pci/controller/pcie-brcmstb.c
+++ b/drivers/pci/controller/pcie-brcmstb.c
@@ -122,7 +122,7 @@
 #define PCIE_RGR1_SW_INIT_1_PERST_SHIFT				0x0
 
 #define BRCM_NUM_PCIE_OUT_WINS		0x4
-#define BRCM_MAX_SCB			0x4
+#define BRCM_MAX_SCB			0x1
 #define BRCM_INT_PCI_MSI_NR		32
 #define BRCM_PCIE_HW_REV_33		0x0303
 
@@ -998,9 +998,10 @@ static int brcm_pcie_add_controller(stru
 	}
 
 	ret = brcm_pcie_parse_map_dma_ranges(pcie);
-	if (ret)
+	if (ret) {
+		dev_err(dev, "failed to parse dma ranges: %d\n", ret);
 		goto done;
-
+	}
 	/* Determine num_memc and their sizes */
 	for (i = 0, num_memc = 0; i < BRCM_MAX_SCB; i++) {
 		u64 size = brcmstb_memory_memc_size(i);
@@ -1013,10 +1014,12 @@ static int brcm_pcie_add_controller(stru
 			scb_size[i] = roundup_pow_of_two_64(size);
 			num_memc++;
 		} else {
+			dev_err(dev, "size = 0\n");
 			break;
 		}
 	}
 	if (!ret && num_memc == 0) {
+		dev_err(dev, "ret=0 and num_memc=0\n");
 		ret = -EINVAL;
 		goto done;
 	}
@@ -1116,8 +1119,21 @@ static int brcm_pcie_setup(struct brcm_p
 	/* Set SCB_MAX_BURST_SIZE, CFG_READ_UR_MODE, SCB_ACCESS_EN */
 	tmp = INSERT_FIELD(0, PCIE_MISC_MISC_CTRL, SCB_ACCESS_EN, 1);
 	tmp = INSERT_FIELD(tmp, PCIE_MISC_MISC_CTRL, CFG_READ_UR_MODE, 1);
-	burst = (pcie->type == GENERIC || pcie->type == BCM7278)
-		? BURST_SIZE_512 : BURST_SIZE_256;
+
+	switch (pcie->type) {
+	case GENERIC:
+		burst = BURST_SIZE_128;
+		break;
+	case BCM7278:
+		burst = BURST_SIZE_512;
+		break;
+	default:
+		burst = BURST_SIZE_256;
+		break;
+	}
+
+	dev_info(dev, "type:%#x, burst:%#x\n", pcie->type, burst);
+
 	tmp = INSERT_FIELD(tmp, PCIE_MISC_MISC_CTRL, MAX_BURST_SIZE, burst);
 	bcm_writel(tmp, base + PCIE_MISC_MISC_CTRL);
 
@@ -1476,25 +1492,32 @@ static int brcm_pcie_probe(struct platfo
 	if (ret)
 		return ret;
 
+	dev_info(pcie->dev, "ches: enabling clk\n");
 	ret = clk_prepare_enable(pcie->clk);
 	if (ret) {
-		dev_err(&pdev->dev, "could not enable clock\n");
+		if (ret != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "could not enable clock\n");
 		return ret;
 	}
+	dev_info(pcie->dev, "ches: add controller\n");
 
 	ret = brcm_pcie_add_controller(pcie);
 	if (ret)
 		return ret;
 
+	dev_info(pcie->dev, "ches: pcie setup\n");
+
 	ret = brcm_pcie_setup(pcie);
 	if (ret)
 		goto fail;
 
+	dev_info(pcie->dev, "ches: parse handle\n");
 	msi_dn = of_parse_phandle(pcie->dn, "msi-parent", 0);
 	/* Use the internal MSI if no msi-parent property */
 	if (!msi_dn)
 		msi_dn = pcie->dn;
 
+	dev_info(pcie->dev, "ches: enable msi\n");
 	if (pci_msi_enabled() && msi_dn == pcie->dn) {
 		ret = brcm_pcie_enable_msi(pcie);
 		if (ret)
@@ -1512,6 +1535,7 @@ static int brcm_pcie_probe(struct platfo
 	bridge->map_irq = of_irq_parse_and_map_pci;
 	bridge->swizzle_irq = pci_common_swizzle;
 
+	dev_info(pcie->dev, "ches: scan root bridge\n");
 	ret = pci_scan_root_bus_bridge(bridge);
 	if (ret < 0) {
 		dev_err(pcie->dev, "Scanning root bridge failed\n");
@@ -1521,10 +1545,11 @@ static int brcm_pcie_probe(struct platfo
 	pci_assign_unassigned_bus_resources(bridge->bus);
 	list_for_each_entry(child, &bridge->bus->children, node)
 		pcie_bus_configure_settings(child);
+	dev_info(pcie->dev, "ches: add device\n");
 	pci_bus_add_devices(bridge->bus);
 	platform_set_drvdata(pdev, pcie);
 	pcie->root_bus = bridge->bus;
-
+	dev_info(pcie->dev, "ches: end\n");
 	return 0;
 fail:
 	_brcm_pcie_remove(pcie);
--- a/drivers/soc/bcm/brcmstb/memory.c
+++ b/drivers/soc/bcm/brcmstb/memory.c
@@ -147,9 +147,10 @@ u64 brcmstb_memory_memc_size(int memc)
 			return -1;
 		}
 
+		pr_info("idx: %d, (%#lx,%lx)\n", memc_idx, addr, size);
 		memc_idx = brcmstb_memory_phys_addr_to_memc((phys_addr_t)addr);
-		if (memc_idx == memc)
-			memc_size += size;
+		//if (memc_idx == memc)
+		memc_size += size;
 	}
 
 	return memc_size;
