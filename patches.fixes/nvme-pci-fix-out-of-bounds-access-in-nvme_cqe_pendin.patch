From: Hongbo Yao <yaohongbo@huawei.com>
Date: Mon, 7 Jan 2019 10:22:07 +0800
Subject: [PATCH] nvme-pci: fix out of bounds access in nvme_cqe_pending
Git-commit: dcca1662727220d18fa351097ddff33f95f516c5
References: bsc#1127595
Patch-Mainline: v5.0-rc2

There is an out of bounds array access in nvme_cqe_peding().

When enable irq_thread for nvme interrupt, there is racing between the
nvmeq->cq_head updating and reading.

nvmeq->cq_head is updated in nvme_update_cq_head(), if nvmeq->cq_head
equals nvmeq->q_depth and before its value set to zero, nvme_cqe_pending()
uses its value as an array index, the index will be out of bounds.

Signed-off-by: Hongbo Yao <yaohongbo@huawei.com>
[hch: slight coding style update]
Signed-off-by: Christoph Hellwig <hch@lst.de>
Acked-by: Hannes Reinecke <hare@suse.com>
---
 drivers/nvme/host/pci.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/drivers/nvme/host/pci.c b/drivers/nvme/host/pci.c
index d9fb622512c8..222c78ec7e27 100644
--- a/drivers/nvme/host/pci.c
+++ b/drivers/nvme/host/pci.c
@@ -973,9 +973,11 @@ static inline bool nvme_read_cqe(struct nvme_queue *nvmeq,
 	if (nvme_cqe_valid(nvmeq, nvmeq->cq_head, nvmeq->cq_phase)) {
 		*cqe = nvmeq->cqes[nvmeq->cq_head];
 
-		if (++nvmeq->cq_head == nvmeq->q_depth) {
+		if (nvmeq->cq_head == nvmeq->q_depth - 1) {
 			nvmeq->cq_head = 0;
 			nvmeq->cq_phase = !nvmeq->cq_phase;
+		} else {
+			nvmeq->cq_head++;
 		}
 		return true;
 	}
-- 
2.16.4

