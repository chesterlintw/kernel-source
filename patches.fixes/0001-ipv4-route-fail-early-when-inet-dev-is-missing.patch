From: Paolo Abeni <pabeni@redhat.com>
Subject: ipv4/route: fail early when inet dev is missing
Patch-mainline: v5.1-rc1
Git-commit: 22c74764aa2943ecdf9f07c900d8a9c8ba6c9265
References: git-fixes


If a non local multicast packet reaches ip_route_input_rcu() while
the ingress device IPv4 private data (in_dev) is NULL, we end up
doing a NULL pointer dereference in IN_DEV_MFORWARD().

Since the later call to ip_route_input_mc() is going to fail if
!in_dev, we can fail early in such scenario and avoid the dangerous
code path.

v1 -> v2:
 - clarified the commit message, no code changes

Reported-by: Tianhao Zhao <tizhao@redhat.com>
Fixes: e58e41596811 ("net: Enable support for VRF with ipv4 multicast")
Signed-off-by: Paolo Abeni <pabeni@redhat.com>
Reviewed-by: David Ahern <dsahern@gmail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Acked-by: Denis Kirjanov <dkirjanov@suse.com>
---
 net/ipv4/route.c | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/net/ipv4/route.c b/net/ipv4/route.c
index 0e0c40d54e34..291c1b13c583 100644
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@ -2105,12 +2105,13 @@ int ip_route_input_noref(struct sk_buff *skb, __be32 daddr, __be32 saddr,
 		struct in_device *in_dev = __in_dev_get_rcu(dev);
 		int our = 0;
 
-		if (in_dev)
-			our = ip_check_mc_rcu(in_dev, daddr, saddr,
+		if (!in_dev)
+			return -EINVAL;
+		our = ip_check_mc_rcu(in_dev, daddr, saddr,
 					      ip_hdr(skb)->protocol);
 
 		/* check l3 master if no match yet */
-		if ((!in_dev || !our) && netif_is_l3_slave(dev)) {
+		if (!our && netif_is_l3_slave(dev)) {
 			struct in_device *l3_in_dev;
 
 			l3_in_dev = __in_dev_get_rcu(skb->dev);
-- 
2.12.3

