From 10baeb16126ee8e1373968399d52e742a0699a54 Mon Sep 17 00:00:00 2001
From: Hannes Reinecke <hare@suse.de>
Date: Mon, 18 Mar 2019 11:11:46 +0100
Subject: [PATCH] nvme: schedule requeue whenever a LIVE state is entered
Patch-Mainline: submitted linux-nvme 2019/03/21
References: bsc#1123105

When undergoing state transitions I/O might be requeued, hence
we always have to schedule requeue_work whenever the nvme device
is live, independent on whether the old state was live or not.

Reported-by: Martin George <martin.george@netapp.com>
Signed-off-by: Hannes Reinecke <hare@suse.com>
---
 drivers/nvme/host/multipath.c | 10 ++++++----
 1 file changed, 6 insertions(+), 4 deletions(-)

diff --git a/drivers/nvme/host/multipath.c b/drivers/nvme/host/multipath.c
index 6e1abe704dc8..159c799662de 100644
--- a/drivers/nvme/host/multipath.c
+++ b/drivers/nvme/host/multipath.c
@@ -355,8 +355,6 @@ static void nvme_mpath_set_live(struct nvme_ns *ns)
 		dev->groups = nvme_ns_id_attr_groups;
 		device_add_disk(&head->subsys->dev, head->disk);
 	}
-
-	kblockd_schedule_work(&ns->head->requeue_work);
 }
 
 static int nvme_parse_ana_log(struct nvme_ctrl *ctrl, void *data,
@@ -415,8 +413,11 @@ static void nvme_update_ns_ana_state(struct nvme_ana_group_desc *desc,
 	ns->ana_state = desc->state;
 	clear_bit(NVME_NS_ANA_PENDING, &ns->flags);
 
-	if (nvme_state_is_live(ns->ana_state) && !nvme_state_is_live(old))
-		nvme_mpath_set_live(ns);
+	if (nvme_state_is_live(ns->ana_state)) {
+		if (!nvme_state_is_live(old))
+			nvme_mpath_set_live(ns);
+		kblockd_schedule_work(&ns->head->requeue_work);
+	}
 	mutex_unlock(&ns->head->lock);
 }
 
@@ -597,6 +598,7 @@ void nvme_mpath_add_disk(struct nvme_ns *ns, struct nvme_id_ns *id)
 		mutex_lock(&ns->head->lock);
 		ns->ana_state = NVME_ANA_OPTIMIZED; 
 		nvme_mpath_set_live(ns);
+		kblockd_schedule_work(&ns->head->requeue_work);
 		mutex_unlock(&ns->head->lock);
 	}
 }
-- 
2.16.4

