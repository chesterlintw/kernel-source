From b469e7e47c8a075cc08bcd1e85d4365134bdcdd5 Mon Sep 17 00:00:00 2001
From: Amir Goldstein <amir73il@gmail.com>
Date: Tue, 30 Oct 2018 20:29:53 +0200
Subject: [PATCH] fanotify: fix handling of events on child sub-directory
Git-commit: b469e7e47c8a075cc08bcd1e85d4365134bdcdd5
Patch-mainline: v4.20-rc3
References: bsc#1122019

When an event is reported on a sub-directory and the parent inode has
a mark mask with FS_EVENT_ON_CHILD|FS_ISDIR, the event will be sent to
fsnotify() even if the event type is not in the parent mark mask
(e.g. FS_OPEN).

Further more, if that event happened on a mount or a filesystem with
a mount/sb mark that does have that event type in their mask, the "on
child" event will be reported on the mount/sb mark.  That is not
desired, because user will get a duplicate event for the same action.

Note that the event reported on the victim inode is never merged with
the event reported on the parent inode, because of the check in
Should_merge(): old_fsn->inode == new_fsn->inode.

Fix this by looking for a match of an actual event type (i.e. not just
FS_ISDIR) in parent's inode mark mask and by not reporting an "on child"
event to group if event type is only found on mount/sb marks.

[backport hint: The bug seems to have always been in fanotify, but this
                patch will only apply cleanly to v4.19.y]

Cc: <stable@vger.kernel.org> # v4.19
Signed-off-by: Amir Goldstein <amir73il@gmail.com>
Signed-off-by: Jan Kara <jack@suse.cz>
Acked-by: Jan Kara <jack@suse.cz>

---
 fs/notify/fanotify/fanotify.c |   10 +++++++---
 fs/notify/fsnotify.c          |    7 ++++---
 2 files changed, 11 insertions(+), 6 deletions(-)

--- a/fs/notify/fanotify/fanotify.c
+++ b/fs/notify/fanotify/fanotify.c
@@ -106,8 +106,8 @@ static bool fanotify_should_send_event(s
 		return false;
 
 	/*
-	 * if the event is for a child and this inode doesn't care about
-	 * events on the child, don't send it!
+	 * If the event is for a child and this mark doesn't care about
+	 * events on a child, don't send it!
 	 */
 	if (inode_mark &&
 	    (!(event_mask & FS_EVENT_ON_CHILD) ||
@@ -116,7 +116,11 @@ static bool fanotify_should_send_event(s
 		marks_ignored_mask |= inode_mark->ignored_mask;
 	}
 
-	if (vfsmnt_mark) {
+	/*
+	 * Mount marks don't care about event on children. Ignore them as
+	 * otherwise we could report some events twice. 
+	 */
+	if (vfsmnt_mark && !(event_mask & FS_EVENT_ON_CHILD)) {
 		marks_mask |= vfsmnt_mark->mask;
 		marks_ignored_mask |= vfsmnt_mark->ignored_mask;
 	}
--- a/fs/notify/fsnotify.c
+++ b/fs/notify/fsnotify.c
@@ -163,9 +163,9 @@ int __fsnotify_parent(const struct path
 	parent = dget_parent(dentry);
 	p_inode = parent->d_inode;
 
-	if (unlikely(!fsnotify_inode_watches_children(p_inode)))
+	if (unlikely(!fsnotify_inode_watches_children(p_inode))) {
 		__fsnotify_update_child_dentry_flags(p_inode);
-	else if (p_inode->i_fsnotify_mask & mask) {
+	} else if (p_inode->i_fsnotify_mask & mask & ALL_FSNOTIFY_EVENTS) {
 		struct name_snapshot name;
 
 		/* we are notifying a parent so come up with the new mask which
@@ -300,7 +300,8 @@ int fsnotify(struct inode *to_tell, __u3
 		inode_node = srcu_dereference(inode_conn->list.first,
 					      &fsnotify_mark_srcu);
 
-	if (mnt) {
+	/* An event "on child" is not intended for a mount mark */
+	if (mnt && !(mask & FS_EVENT_ON_CHILD)) {
 		inode_conn = srcu_dereference(to_tell->i_fsnotify_marks,
 					      &fsnotify_mark_srcu);
 		if (inode_conn)
