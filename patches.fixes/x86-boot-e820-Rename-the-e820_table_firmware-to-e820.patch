From a09bae0f8aa08d4d76d0ebece26062a49ec51ac9 Mon Sep 17 00:00:00 2001
From: Chen Yu <yu.c.chen@intel.com>
Date: Mon, 3 Jul 2017 01:07:12 +0800
Subject: [PATCH] x86/boot/e820: Rename the e820_table_firmware to e820_table_kexec
Git-commit: a09bae0f8aa08d4d76d0ebece26062a49ec51ac9
Patch-mainline: v4.13-rc1
References: bsc#1127154

Currently the e820_table_firmware[] table is mainly used by the kexec,
and it is not what it's supposed to be - despite its name it might be
modified by the kernel.

So change its name to e820_table_kexec[]. In the next patch we will
introduce the real e820_table_firmware[] table.

No functional change.

Signed-off-by: Chen Yu <yu.c.chen@intel.com>
Cc: Linus Torvalds <torvalds@linux-foundation.org>
Cc: Peter Zijlstra <peterz@infradead.org>
Cc: Thomas Gleixner <tglx@linutronix.de>
Cc: Xunlei Pang <xlpang@redhat.com>
Cc: linux-kernel@vger.kernel.org
Signed-off-by: Ingo Molnar <mingo@kernel.org>
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 arch/x86/include/asm/e820/api.h   |  2 +-
 arch/x86/kernel/e820.c            | 42 +++++++++++++++++++--------------------
 arch/x86/kernel/kexec-bzimage64.c |  4 ++--
 arch/x86/power/hibernate_64.c     |  4 ++--
 4 files changed, 26 insertions(+), 26 deletions(-)

diff --git a/arch/x86/include/asm/e820/api.h b/arch/x86/include/asm/e820/api.h
index 8e0f8b85b209..a688095421ab 100644
--- a/arch/x86/include/asm/e820/api.h
+++ b/arch/x86/include/asm/e820/api.h
@@ -4,7 +4,7 @@
 #include <asm/e820/types.h>
 
 extern struct e820_table *e820_table;
-extern struct e820_table *e820_table_firmware;
+extern struct e820_table *e820_table_kexec;
 
 extern unsigned long pci_mem_start;
 
diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index c87223e5b1aa..591019031e23 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -22,7 +22,7 @@
 /*
  * We organize the E820 table into two main data structures:
  *
- * - 'e820_table_firmware': the original firmware version passed to us by the
+ * - 'e820_table_kexec': the original firmware version passed to us by the
  *   bootloader - not modified by the kernel. We use this to:
  *
  *       - inform the user about the firmware's notion of memory layout
@@ -46,10 +46,10 @@
  * specific memory layout data during early bootup.
  */
 static struct e820_table e820_table_init		__initdata;
-static struct e820_table e820_table_firmware_init	__initdata;
+static struct e820_table e820_table_kexec_init		__initdata;
 
 struct e820_table *e820_table __refdata			= &e820_table_init;
-struct e820_table *e820_table_firmware __refdata	= &e820_table_firmware_init;
+struct e820_table *e820_table_kexec __refdata		= &e820_table_kexec_init;
 
 /* For PCI or other memory-mapped resources */
 unsigned long pci_mem_start = 0xaeedbabe;
@@ -470,9 +470,9 @@ u64 __init e820__range_update(u64 start, u64 size, enum e820_type old_type, enum
 	return __e820__range_update(e820_table, start, size, old_type, new_type);
 }
 
-static u64 __init e820__range_update_firmware(u64 start, u64 size, enum e820_type old_type, enum e820_type  new_type)
+static u64 __init e820__range_update_kexec(u64 start, u64 size, enum e820_type old_type, enum e820_type  new_type)
 {
-	return __e820__range_update(e820_table_firmware, start, size, old_type, new_type);
+	return __e820__range_update(e820_table_kexec, start, size, old_type, new_type);
 }
 
 /* Remove a range of memory from the E820 table: */
@@ -546,9 +546,9 @@ void __init e820__update_table_print(void)
 	e820__print_table("modified");
 }
 
-static void __init e820__update_table_firmware(void)
+static void __init e820__update_table_kexec(void)
 {
-	e820__update_table(e820_table_firmware);
+	e820__update_table(e820_table_kexec);
 }
 
 #define MAX_GAP_END 0x100000000ull
@@ -623,7 +623,7 @@ __init void e820__setup_pci_gap(void)
 /*
  * Called late during init, in free_initmem().
  *
- * Initial e820_table and e820_table_firmware are largish __initdata arrays.
+ * Initial e820_table and e820_table_kexec are largish __initdata arrays.
  *
  * Copy them to a (usually much smaller) dynamically allocated area that is
  * sized precisely after the number of e820 entries.
@@ -643,11 +643,11 @@ __init void e820__reallocate_tables(void)
 	memcpy(n, e820_table, size);
 	e820_table = n;
 
-	size = offsetof(struct e820_table, entries) + sizeof(struct e820_entry)*e820_table_firmware->nr_entries;
+	size = offsetof(struct e820_table, entries) + sizeof(struct e820_entry)*e820_table_kexec->nr_entries;
 	n = kmalloc(size, GFP_KERNEL);
 	BUG_ON(!n);
-	memcpy(n, e820_table_firmware, size);
-	e820_table_firmware = n;
+	memcpy(n, e820_table_kexec, size);
+	e820_table_kexec = n;
 }
 
 /*
@@ -669,7 +669,7 @@ void __init e820__memory_setup_extended(u64 phys_addr, u32 data_len)
 	__append_e820_table(extmap, entries);
 	e820__update_table(e820_table);
 
-	memcpy(e820_table_firmware, e820_table, sizeof(*e820_table_firmware));
+	memcpy(e820_table_kexec, e820_table, sizeof(*e820_table_kexec));
 
 	early_memunmap(sdata, data_len);
 	pr_info("e820: extended physical RAM map:\n");
@@ -729,7 +729,7 @@ core_initcall(e820__register_nvs_regions);
 /*
  * Allocate the requested number of bytes with the requsted alignment
  * and return (the physical address) to the caller. Also register this
- * range in the 'firmware' E820 table as a reserved range.
+ * range in the 'kexec' E820 table as a reserved range.
  *
  * This allows kexec to fake a new mptable, as if it came from the real
  * system.
@@ -740,9 +740,9 @@ u64 __init e820__memblock_alloc_reserved(u64 size, u64 align)
 
 	addr = __memblock_alloc_base(size, align, MEMBLOCK_ALLOC_ACCESSIBLE);
 	if (addr) {
-		e820__range_update_firmware(addr, size, E820_TYPE_RAM, E820_TYPE_RESERVED);
-		pr_info("e820: update e820_table_firmware for e820__memblock_alloc_reserved()\n");
-		e820__update_table_firmware();
+		e820__range_update_kexec(addr, size, E820_TYPE_RAM, E820_TYPE_RESERVED);
+		pr_info("e820: update e820_table_kexec for e820__memblock_alloc_reserved()\n");
+		e820__update_table_kexec();
 	}
 
 	return addr;
@@ -925,13 +925,13 @@ void __init e820__reserve_setup_data(void)
 	while (pa_data) {
 		data = early_memremap(pa_data, sizeof(*data));
 		e820__range_update(pa_data, sizeof(*data)+data->len, E820_TYPE_RAM, E820_TYPE_RESERVED_KERN);
-		e820__range_update_firmware(pa_data, sizeof(*data)+data->len, E820_TYPE_RAM, E820_TYPE_RESERVED_KERN);
+		e820__range_update_kexec(pa_data, sizeof(*data)+data->len, E820_TYPE_RAM, E820_TYPE_RESERVED_KERN);
 		pa_data = data->next;
 		early_memunmap(data, sizeof(*data));
 	}
 
 	e820__update_table(e820_table);
-	e820__update_table(e820_table_firmware);
+	e820__update_table(e820_table_kexec);
 
 	pr_info("extended physical RAM map:\n");
 	e820__print_table("reserve setup_data");
@@ -1064,8 +1064,8 @@ void __init e820__reserve_resources(void)
 		res++;
 	}
 
-	for (i = 0; i < e820_table_firmware->nr_entries; i++) {
-		struct e820_entry *entry = e820_table_firmware->entries + i;
+	for (i = 0; i < e820_table_kexec->nr_entries; i++) {
+		struct e820_entry *entry = e820_table_kexec->entries + i;
 
 		firmware_map_add_early(entry->addr, entry->addr + entry->size, e820_type_to_string(entry));
 	}
@@ -1177,7 +1177,7 @@ void __init e820__memory_setup(void)
 
 	who = x86_init.resources.memory_setup();
 
-	memcpy(e820_table_firmware, e820_table, sizeof(*e820_table_firmware));
+	memcpy(e820_table_kexec, e820_table, sizeof(*e820_table_kexec));
 
 	pr_info("e820: BIOS-provided physical RAM map:\n");
 	e820__print_table(who);
diff --git a/arch/x86/kernel/kexec-bzimage64.c b/arch/x86/kernel/kexec-bzimage64.c
index 9d7fd5e6689a..fb095ba0c02f 100644
--- a/arch/x86/kernel/kexec-bzimage64.c
+++ b/arch/x86/kernel/kexec-bzimage64.c
@@ -100,14 +100,14 @@ static int setup_e820_entries(struct boot_params *params)
 {
 	unsigned int nr_e820_entries;
 
-	nr_e820_entries = e820_table_firmware->nr_entries;
+	nr_e820_entries = e820_table_kexec->nr_entries;
 
 	/* TODO: Pass entries more than E820_MAX_ENTRIES_ZEROPAGE in bootparams setup data */
 	if (nr_e820_entries > E820_MAX_ENTRIES_ZEROPAGE)
 		nr_e820_entries = E820_MAX_ENTRIES_ZEROPAGE;
 
 	params->e820_entries = nr_e820_entries;
-	memcpy(&params->e820_table, &e820_table_firmware->entries, nr_e820_entries*sizeof(struct e820_entry));
+	memcpy(&params->e820_table, &e820_table_kexec->entries, nr_e820_entries*sizeof(struct e820_entry));
 
 	return 0;
 }
diff --git a/arch/x86/power/hibernate_64.c b/arch/x86/power/hibernate_64.c
index e3e62c8a8e70..3ba161a08d6e 100644
--- a/arch/x86/power/hibernate_64.c
+++ b/arch/x86/power/hibernate_64.c
@@ -251,7 +251,7 @@ static int get_e820_md5(struct e820_table *table, void *buf)
 
 static void hibernation_e820_save(void *buf)
 {
-	get_e820_md5(e820_table_firmware, buf);
+	get_e820_md5(e820_table_kexec, buf);
 }
 
 static bool hibernation_e820_mismatch(void *buf)
@@ -264,7 +264,7 @@ static bool hibernation_e820_mismatch(void *buf)
 	if (!memcmp(result, buf, MD5_DIGEST_SIZE))
 		return false;
 
-	ret = get_e820_md5(e820_table_firmware, result);
+	ret = get_e820_md5(e820_table_kexec, result);
 	if (ret)
 		return true;
 
-- 
2.16.4

