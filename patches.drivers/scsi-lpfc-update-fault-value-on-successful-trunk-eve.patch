From: James Smart <jsmart2021@gmail.com>
Date: Thu, 13 Dec 2018 15:17:54 -0800
Subject: [PATCH] scsi: lpfc: update fault value on successful trunk events.
Git-commit: 529b3ddcfff580a2457eceeda9f248bc77c49246
Patch-mainline: v5.0-rc1
References: bsc#1121317

Currently, when a trunk link goes down due to some fault, the driver
snapshots the fault code.  If the link then comes back up, meaning there is
no fault, the driver is not clearing the fault code so the sysfs link_state
entry reports old/stale data.

Revise the logic so that on successful link up the fault code is cleared.

Signed-off-by: Dick Kennedy <dick.kennedy@broadcom.com>
Signed-off-by: James Smart <jsmart2021@gmail.com>
Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
Acked-by: Hannes Reinecke <hare@suse.com>
---
 drivers/scsi/lpfc/lpfc_init.c | 12 ++++--------
 1 file changed, 4 insertions(+), 8 deletions(-)

diff --git a/drivers/scsi/lpfc/lpfc_init.c b/drivers/scsi/lpfc/lpfc_init.c
index c56ef73463f2..2b8baf190165 100644
--- a/drivers/scsi/lpfc/lpfc_init.c
+++ b/drivers/scsi/lpfc/lpfc_init.c
@@ -4707,29 +4707,25 @@ lpfc_update_trunk_link_status(struct lpfc_hba *phba,
 		phba->trunk_link.link0.state =
 			bf_get(lpfc_acqe_fc_la_trunk_link_status_port0, acqe_fc)
 			? LPFC_LINK_UP : LPFC_LINK_DOWN;
-		if (port_fault & 0x1)
-			phba->trunk_link.link0.fault = err;
+		phba->trunk_link.link0.fault = port_fault & 0x1 ? err : 0;
 	}
 	if (bf_get(lpfc_acqe_fc_la_trunk_config_port1, acqe_fc)) {
 		phba->trunk_link.link1.state =
 			bf_get(lpfc_acqe_fc_la_trunk_link_status_port1, acqe_fc)
 			? LPFC_LINK_UP : LPFC_LINK_DOWN;
-		if (port_fault & 0x2)
-			phba->trunk_link.link1.fault = err;
+		phba->trunk_link.link1.fault = port_fault & 0x2 ? err : 0;
 	}
 	if (bf_get(lpfc_acqe_fc_la_trunk_config_port2, acqe_fc)) {
 		phba->trunk_link.link2.state =
 			bf_get(lpfc_acqe_fc_la_trunk_link_status_port2, acqe_fc)
 			? LPFC_LINK_UP : LPFC_LINK_DOWN;
-		if (port_fault & 0x4)
-			phba->trunk_link.link2.fault = err;
+		phba->trunk_link.link2.fault = port_fault & 0x4 ? err : 0;
 	}
 	if (bf_get(lpfc_acqe_fc_la_trunk_config_port3, acqe_fc)) {
 		phba->trunk_link.link3.state =
 			bf_get(lpfc_acqe_fc_la_trunk_link_status_port3, acqe_fc)
 			? LPFC_LINK_UP : LPFC_LINK_DOWN;
-		if (port_fault & 0x8)
-			phba->trunk_link.link3.fault = err;
+		phba->trunk_link.link3.fault = port_fault & 0x8 ? err : 0;
 	}
 
 	lpfc_printf_log(phba, KERN_ERR, LOG_SLI,
-- 
2.16.4

