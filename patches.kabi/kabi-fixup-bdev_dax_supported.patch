From: Johannes Thumshirn <jthumshirn@suse.de>
Subject: kabi protect bdev_dax_supported
Date: Tue Aug  7 15:11:48 CEST 2018
Patch-mainline: Never, KABI fixup
References: bsc#1103917

Signed-off-by: Johannes Thumshirn <jthumshirn@suse.de>
---
 drivers/dax/super.c   |   14 ++++++++++++--
 drivers/md/dm-table.c |    2 +-
 fs/ext2/super.c       |    2 +-
 fs/ext4/super.c       |    2 +-
 fs/xfs/xfs_ioctl.c    |    2 +-
 fs/xfs/xfs_super.c    |    4 ++--
 include/linux/dax.h   |   10 ++++++----
 7 files changed, 24 insertions(+), 12 deletions(-)

--- a/drivers/dax/super.c
+++ b/drivers/dax/super.c
@@ -73,7 +73,7 @@ EXPORT_SYMBOL_GPL(fs_dax_get_by_bdev);
 #endif
 
 /**
- * __bdev_dax_supported() - Check if the device supports dax for filesystem
+ * ____bdev_dax_supported() - Check if the device supports dax for filesystem
  * @bdev: block device to check
  * @blocksize: The block size of the device
  *
@@ -82,8 +82,9 @@ EXPORT_SYMBOL_GPL(fs_dax_get_by_bdev);
  *
  * Return: negative errno if unsupported, 0 if supported.
  */
-int __bdev_dax_supported(struct block_device *bdev, int blocksize)
+int ____bdev_dax_supported(struct block_device *bdev, int blocksize)
 {
+#if IS_ENABLED(CONFIG_FS_DAX)
 	struct dax_device *dax_dev;
 	pgoff_t pgoff;
 	struct request_queue *q;
@@ -151,6 +152,15 @@ int __bdev_dax_supported(struct block_de
 	}
 
 	return 0;
+#else
+	return -EOPNOTSUPP;
+#endif
+}
+EXPORT_SYMBOL_GPL(____bdev_dax_supported);
+
+int __bdev_dax_supported(struct super_block *sb, int blocksize)
+{
+	return ____bdev_dax_supported(sb->s_bdev, blocksize);
 }
 EXPORT_SYMBOL_GPL(__bdev_dax_supported);
 #endif
--- a/drivers/md/dm-table.c
+++ b/drivers/md/dm-table.c
@@ -889,7 +889,7 @@ EXPORT_SYMBOL_GPL(dm_table_set_type);
 static int device_supports_dax(struct dm_target *ti, struct dm_dev *dev,
 			       sector_t start, sector_t len, void *data)
 {
-	return bdev_dax_supported(dev->bdev, PAGE_SIZE);
+	return ____bdev_dax_supported(dev->bdev, PAGE_SIZE);
 }
 
 static bool dm_table_supports_dax(struct dm_table *t)
--- a/fs/ext2/super.c
+++ b/fs/ext2/super.c
@@ -955,7 +955,7 @@ static int ext2_fill_super(struct super_
 	blocksize = BLOCK_SIZE << le32_to_cpu(sbi->s_es->s_log_block_size);
 
 	if (sbi->s_mount_opt & EXT2_MOUNT_DAX) {
-		err = bdev_dax_supported(sb->s_bdev, blocksize);
+		err = ____bdev_dax_supported(sb->s_bdev, blocksize);
 		if (err) {
 			ext2_msg(sb, KERN_ERR,
 				"DAX unsupported by block device. Turning off DAX.");
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -3761,7 +3761,7 @@ static int ext4_fill_super(struct super_
 					" that may contain inline data");
 			sbi->s_mount_opt &= ~EXT4_MOUNT_DAX;
 		}
-		err = bdev_dax_supported(sb->s_bdev, blocksize);
+		err = ____bdev_dax_supported(sb->s_bdev, blocksize);
 		if (err) {
 			ext4_msg(sb, KERN_ERR,
 				"DAX unsupported by block device. Turning off DAX.");
--- a/fs/xfs/xfs_ioctl.c
+++ b/fs/xfs/xfs_ioctl.c
@@ -1102,7 +1102,7 @@ xfs_ioctl_setattr_dax_invalidate(
 	if (fa->fsx_xflags & FS_XFLAG_DAX) {
 		if (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode)))
 			return -EINVAL;
-		if (bdev_dax_supported(xfs_find_bdev_for_inode(VFS_I(ip)),
+		if (____bdev_dax_supported(xfs_find_bdev_for_inode(VFS_I(ip)),
 				sb->s_blocksize) < 0)
 			return -EINVAL;
 	}
--- a/fs/xfs/xfs_super.c
+++ b/fs/xfs/xfs_super.c
@@ -1661,10 +1661,10 @@ xfs_fs_fill_super(
 		int	error2 = -EINVAL;
 
 
-		error = bdev_dax_supported(mp->m_ddev_targp->bt_bdev,
+		error = ____bdev_dax_supported(mp->m_ddev_targp->bt_bdev,
 				sb->s_blocksize);
 		if (mp->m_rtdev_targp)
-			error2 = bdev_dax_supported(mp->m_rtdev_targp->bt_bdev,
+			error2 = ____bdev_dax_supported(mp->m_rtdev_targp->bt_bdev,
 					sb->s_blocksize);
 		if (error && error2) {
 			xfs_alert(mp,
--- a/include/linux/dax.h
+++ b/include/linux/dax.h
@@ -43,10 +43,11 @@ static inline void put_dax(struct dax_de
 struct writeback_control;
 int bdev_dax_pgoff(struct block_device *, sector_t, size_t, pgoff_t *pgoff);
 #if IS_ENABLED(CONFIG_FS_DAX)
-int __bdev_dax_supported(struct block_device *bdev, int blocksize);
-static inline int bdev_dax_supported(struct block_device *bdev, int blocksize)
+int ____bdev_dax_supported(struct block_device *bdev, int blocksize);
+int __bdev_dax_supported(struct super_block *sb, int blocksize);
+static inline int bdev_dax_supported(struct super_block *sb, int blocksize)
 {
-	return __bdev_dax_supported(bdev, blocksize);
+	return __bdev_dax_supported(sb, blocksize);
 }
 
 static inline struct dax_device *fs_dax_get_by_host(const char *host)
@@ -65,7 +66,8 @@ int dax_writeback_mapping_range(struct a
 bool dax_lock_mapping_entry(struct page *page);
 void dax_unlock_mapping_entry(struct page *page);
 #else
-static inline int bdev_dax_supported(struct block_device *bdev,
+int ____bdev_dax_supported(struct block_device *bdev, int blocksize);
+static inline int bdev_dax_supported(struct super_block *sb,
 		int blocksize)
 {
 	return -EOPNOTSUPP;
