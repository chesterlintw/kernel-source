From: Jiri Slaby <jslaby@suse.cz>
Subject: memcg: make it work on sparse non-0-node systems kabi
Patch-mainline: never, kabi
References: bnc#1133616

The orignal fix is in commit 3e8589963773a5c23e2f1fe4bcad0e9a90b7f471.
But the commit adds a bool to struct list_lru and it breaks kABI as
list_lru is embedded in struct super_block. Instead of this new flag,
use first_online_node here.

Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 include/linux/list_lru.h |    1 -
 mm/list_lru.c            |    4 +---
 2 files changed, 1 insertion(+), 4 deletions(-)

--- a/include/linux/list_lru.h
+++ b/include/linux/list_lru.h
@@ -51,7 +51,6 @@ struct list_lru {
 	struct list_lru_node	*node;
 #if defined(CONFIG_MEMCG) && !defined(CONFIG_SLOB)
 	struct list_head	list;
-	bool			memcg_aware;
 #endif
 };
 
--- a/mm/list_lru.c
+++ b/mm/list_lru.c
@@ -42,7 +42,7 @@ static void list_lru_unregister(struct l
 #if defined(CONFIG_MEMCG) && !defined(CONFIG_SLOB)
 static inline bool list_lru_memcg_aware(struct list_lru *lru)
 {
-	return lru->memcg_aware;
+	return !!lru->node[first_online_node].memcg_lrus;
 }
 
 static inline struct list_lru_one *
@@ -385,8 +385,6 @@ static int memcg_init_list_lru(struct li
 {
 	int i;
 
-	lru->memcg_aware = memcg_aware;
-
 	if (!memcg_aware)
 		return 0;
 
