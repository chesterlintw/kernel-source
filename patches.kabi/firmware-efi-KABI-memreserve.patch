From: Matthias Brugger <mbrugger@suse.com>
Subject: firmware: efi: factor out mem_reserve
Patch-mainline: never, kabi
References: bsc#1117158 bsc#1134671

Upstream commit
976b489120cd ("efi: Prevent GICv3 WARN() by mapping the memreserve table before first use")
63eb322d89c8 ("efi: Permit calling efi_mem_reserve_persistent() from atomic context")
a23d3bb05ccb ("efi: add API to reserve memory persistently across kexec reboot")
and
71e0940d52e1 ("efi: honour memory reservations passed via a linux specific config table")
use and introduce the new member mem_reserve of struct efi.
This breaks KABI. As the only user of struct efi is the efi code itself, we change it
to a global variable, which should do the trick.

Signed-off-by: Matthias Brugger <mbrugger@suse.com>
---
 drivers/firmware/efi/efi.c |   16 ++++++++++------
 include/linux/efi.h        |    1 -
 2 files changed, 10 insertions(+), 7 deletions(-)

--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -52,10 +52,14 @@ struct efi __read_mostly efi = {
 	.properties_table	= EFI_INVALID_TABLE_ADDR,
 	.mem_attr_table		= EFI_INVALID_TABLE_ADDR,
 	.rng_seed		= EFI_INVALID_TABLE_ADDR,
-	.mem_reserve		= EFI_INVALID_TABLE_ADDR,
 };
 EXPORT_SYMBOL(efi);
 
+ /* Linux EFI memreserve table
+  * Declared as global variable for not breaking KABI
+  */
+unsigned long mem_reserve	= EFI_INVALID_TABLE_ADDR;
+
 static unsigned long *efi_tables[] = {
 	&efi.mps,
 	&efi.acpi,
@@ -467,7 +471,7 @@ static __initdata efi_config_table_type_
 	{EFI_PROPERTIES_TABLE_GUID, "PROP", &efi.properties_table},
 	{EFI_MEMORY_ATTRIBUTES_TABLE_GUID, "MEMATTR", &efi.mem_attr_table},
 	{LINUX_EFI_RANDOM_SEED_TABLE_GUID, "RNG", &efi.rng_seed},
-	{LINUX_EFI_MEMRESERVE_TABLE_GUID, "MEMRESERVE", &efi.mem_reserve},
+	{LINUX_EFI_MEMRESERVE_TABLE_GUID, "MEMRESERVE", &mem_reserve},
 	{NULL_GUID, NULL, NULL},
 };
 
@@ -572,8 +576,8 @@ int __init efi_config_parse_tables(void
 		early_memunmap(tbl, sizeof(*tbl));
 	}
 
-	if (efi.mem_reserve != EFI_INVALID_TABLE_ADDR) {
-		unsigned long prsv = efi.mem_reserve;
+	if (mem_reserve != EFI_INVALID_TABLE_ADDR) {
+		unsigned long prsv = mem_reserve;
 
 		while (prsv) {
 			struct linux_efi_memreserve *rsv;
@@ -933,10 +937,10 @@ static struct linux_efi_memreserve *efi_
 
 static int __init efi_memreserve_map_root(void)
 {
-	if (efi.mem_reserve == EFI_INVALID_TABLE_ADDR)
+	if (mem_reserve == EFI_INVALID_TABLE_ADDR)
 		return -ENODEV;
 
-	efi_memreserve_root = memremap(efi.mem_reserve,
+	efi_memreserve_root = memremap(mem_reserve,
 				       sizeof(*efi_memreserve_root),
 				       MEMREMAP_WB);
 	if (WARN_ON_ONCE(!efi_memreserve_root))
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -922,7 +922,6 @@ extern struct efi {
 	unsigned long properties_table;	/* properties table */
 	unsigned long mem_attr_table;	/* memory attributes table */
 	unsigned long rng_seed;		/* UEFI firmware random seed */
-	unsigned long mem_reserve;	/* Linux EFI memreserve table */
 	efi_get_time_t *get_time;
 	efi_set_time_t *set_time;
 	efi_get_wakeup_time_t *get_wakeup_time;
